<!DOCTYPE html>
<!--npm start -->
<html lang="en">
<head>
<meta charset="utf-8" />
<link rel="icon" type="image/png" type="image/x-icon" href="https://i.ibb.co/wQFsp1d/Logo.png">

<title>PinPoint</title>

   

<meta name="viewport" content="width=device-width, initial-scale=1" />
<script src="https://api.tiles.mapbox.com/mapbox-gl-js/v2.14.1/mapbox-gl.js"></script>
<link href="https://api.tiles.mapbox.com/mapbox-gl-js/v2.14.1/mapbox-gl.css" rel="stylesheet" />
<script src="https://api.mapbox.com/mapbox-gl-js/plugins/mapbox-gl-geocoder/v4.7.0/mapbox-gl-geocoder.min.js"></script>
<link rel="stylesheet" href="https://api.mapbox.com/mapbox-gl-js/plugins/mapbox-gl-geocoder/v4.7.0/mapbox-gl-geocoder.css" type="text/css" />
<script src="https://api.mapbox.com/mapbox-gl-js/plugins/mapbox-gl-directions/v4.1.0/mapbox-gl-directions.js"></script>
<link rel="stylesheet" href="https://api.mapbox.com/mapbox-gl-js/plugins/mapbox-gl-directions/v4.1.0/mapbox-gl-directions.css" type="text/css" />
<link href="https://api.mapbox.com/mapbox-gl-js/v2.15.0/mapbox-gl.css" rel="stylesheet">
<script src="https://api.mapbox.com/mapbox-gl-js/v2.15.0/mapbox-gl.js"></script>
 
<script src="service-worker.js">  </script>
<script> if('serviceWorker' in navigator) {
  let registration;

  const registerServiceWorker = async () => {
    registration = await          navigator.serviceWorker.register('./service-worker.js');
  };

  registerServiceWorker();
}</script>

<script src="https://unpkg.com/htmx.org@1.9.5" integrity="sha384-xcuj3WpfgjlKF+FXhSQFQ0ZNr39ln+hwjN3npfM9VBnUskLolQAcN80McRIVOPuO" crossorigin="anonymous"></script>
<style>
  body {
    margin: 0;
    padding: 0;
    background-color:#c1dade;
    display:flex;
    flex-direction:column;
  }
  #map {
    height: 100vh;
    width: 100vw;
    position: absolute; top: 0; bottom: 0;
    z-index:0;
  }
</style>
<style> body {
      -webkit-animation: colorchange 20s infinite;
      animation: colorchange 20s infinite;
    }
    /* #512DA8  #673AB7  */
    @-webkit-keyframes colorchange {
      25% {
        background: #d3d3d3;
      }
      50% {
        background: #666bb8;
      }
      100% {
        background: #755ddf;
      }
     
    }
    @keyframes colorchange {
      10% {
        background: #d3d3d3;
      }
      15.4%{
        background:#c1dade;
      }
      30% {
        background: #21c2db;
      }
      50% {
        background: #0d2633;
      }
      75% {
        background:#222;
      }
      100% {
        background: #171717;
      }
    }
.pin {
width: 31.4px;
height: 30.5px;
border-radius: 50% 50% 50% 0;
background: #00FFFF;
position: absolute;
-webkit-transform: rotate(-45deg);
-moz-transform: rotate(-45deg);
-o-transform: rotate(-45deg);
-ms-transform: rotate(-45deg);
transform: rotate(-45deg);
left: 50%;
top: 50%;
margin: -20px 0 0 -21.6px;
-webkit-animation-name: bounce;
-moz-animation-name: bounce;
-o-animation-name: bounce;
-ms-animation-name: bounce;
animation-name: bounce;
-webkit-animation-fill-mode: both;
-moz-animation-fill-mode: both;
-o-animation-fill-mode: both;
-ms-animation-fill-mode: both;
animation-fill-mode: both;
-webkit-animation-duration: 1s;
-moz-animation-duration: 1s;
-o-animation-duration: 1s;
-ms-animation-duration: 1s;
animation-duration: 1s;

 border: 00.1px solid #2f2f2f;
}
.pin:after {
content: '';
width: 14px;
height: 14px;
margin: 8px  8px;
background:#d3d3d3 ;
position: absolute;
border-radius: 50%;
 border: 000.1px solid #2f2f2f;
}
.pulse {
background: rgba(#00FFFF);
border-radius: 50%;
height: 14px;
width: 14px;
position: absolute;
left: 50%;
top: 50%;
margin: 11px 0px 0px -12px;
-webkit-transform: rotateX(55deg);
-moz-transform: rotateX(55deg);
-o-transform: rotateX(55deg);
-ms-transform: rotateX(55deg);
transform: rotateX(55deg);
z-index: -2;
}
.pulse:after {
content: "";
border-radius: 50%;
height: 40px;
width: 40px;
position: absolute;
margin: -13px 0 0 -13px;
-webkit-animation: pulsate 1s ease-out;
-moz-animation: pulsate 1s ease-out;
-o-animation: pulsate 1s ease-out;
-ms-animation: pulsate 1s ease-out;
animation: pulsate 1s ease-out;
-webkit-animation-iteration-count: infinite;
-moz-animation-iteration-count: infinite;
-o-animation-iteration-count: infinite;
-ms-animation-iteration-count: infinite;
animation-iteration-count: infinite;
opacity: 0;
-ms-filter: "progid:DXImageTransform.Microsoft.Alpha(Opacity=0)";
filter: alpha(opacity=0);
-webkit-box-shadow: 0 0 1px 2px black;
box-shadow: 0 0 1px 2px black;
-webkit-animation-delay: 1.1s;
-moz-animation-delay: 1.1s;
-o-animation-delay: 1.1s;
-ms-animation-delay: 1.1s;
animation-delay: 1.1s;
}
@-moz-keyframes pulsate {
0% {
  -webkit-transform: scale(0.1, 0.1);
  -moz-transform: scale(0.1, 0.1);
  -o-transform: scale(0.1, 0.1);
  -ms-transform: scale(0.1, 0.1);
  transform: scale(0.1, 0.1);
  opacity: 0;
  -ms-filter: "progid:DXImageTransform.Microsoft.Alpha(Opacity=0)";
  filter: alpha(opacity=0);
}
50% {
  opacity: 1;
  -ms-filter: none;
  filter: none;
}
100% {
  -webkit-transform: scale(1.2, 1.2);
  -moz-transform: scale(1.2, 1.2);
  -o-transform: scale(1.2, 1.2);
  -ms-transform: scale(1.2, 1.2);
  transform: scale(1.2, 1.2);
  opacity: 0;
  -ms-filter: "progid:DXImageTransform.Microsoft.Alpha(Opacity=0)";
  filter: alpha(opacity=0);
}
}
@-webkit-keyframes pulsate {
0% {
  -webkit-transform: scale(0.1, 0.1);
  -moz-transform: scale(0.1, 0.1);
  -o-transform: scale(0.1, 0.1);
  -ms-transform: scale(0.1, 0.1);
  transform: scale(0.1, 0.1);
  opacity: 0;
  -ms-filter: "progid:DXImageTransform.Microsoft.Alpha(Opacity=0)";
  filter: alpha(opacity=0);
}50% {
  opacity: 1;
  -ms-filter: none;
  filter: none;
}
100% {
  -webkit-transform: scale(1.2, 1.2);
  -moz-transform: scale(1.2, 1.2);
  -o-transform: scale(1.2, 1.2);
  -ms-transform: scale(1.2, 1.2);
  transform: scale(1.2, 1.2);
  opacity: 0;
  -ms-filter: "progid:DXImageTransform.Microsoft.Alpha(Opacity=0)";
  filter: alpha(opacity=0);
}
}
@-o-keyframes pulsate {
0% {
  -webkit-transform: scale(0.1, 0.1);
  -moz-transform: scale(0.1, 0.1);
  -o-transform: scale(0.1, 0.1);
  -ms-transform: scale(0.1, 0.1);
  transform: scale(0.1, 0.1);
  opacity: 0;
  -ms-filter: "progid:DXImageTransform.Microsoft.Alpha(Opacity=0)";
  filter: alpha(opacity=0);
}
50% {
  opacity: 1;
  -ms-filter: none;
  filter: none;
}
100% {
  -webkit-transform: scale(1.2, 1.2);
  -moz-transform: scale(1.2, 1.2);
  -o-transform: scale(1.2, 1.2);
  -ms-transform: scale(1.2, 1.2);
  transform: scale(1.2, 1.2);
  opacity: 0;
  -ms-filter: "progid:DXImageTransform.Microsoft.Alpha(Opacity=0)";
  filter: alpha(opacity=0);
}
}
@keyframes pulsate {
0% {
  -webkit-transform: scale(0.1, 0.1);
  -moz-transform: scale(0.1, 0.1);
  -o-transform: scale(0.1, 0.1);
  -ms-transform: scale(0.1, 0.1);
  transform: scale(0.1, 0.1);
  opacity: 0;
  -ms-filter: "progid:DXImageTransform.Microsoft.Alpha(Opacity=0)";
  filter: alpha(opacity=0);
}
50% {
  opacity: 1;
  -ms-filter: none;
  filter: none;
}
100% {
  -webkit-transform: scale(1.2, 1.2);
  -moz-transform: scale(1.2, 1.2);
  -o-transform: scale(1.2, 1.2);
  -ms-transform: scale(1.2, 1.2);
  transform: scale(1.2, 1.2);
  opacity: 0;
  -ms-filter: "progid:DXImageTransform.Microsoft.Alpha(Opacity=0)";
  filter: alpha(opacity=0);
}
}
@-moz-keyframes bounce {
0% {
  opacity: 0;
  -ms-filter: "progid:DXImageTransform.Microsoft.Alpha(Opacity=0)";
  filter: alpha(opacity=0);
  -webkit-transform: translateY(-2000px) rotate(-45deg);
  -moz-transform: translateY(-2000px) rotate(-45deg);
  -o-transform: translateY(-2000px) rotate(-45deg);
  -ms-transform: translateY(-2000px) rotate(-45deg);
  transform: translateY(-2000px) rotate(-45deg);
}
60% {
  opacity: 1;
  -ms-filter: none;
  filter: none;
  -webkit-transform: translateY(30px) rotate(-45deg);
  -moz-transform: translateY(30px) rotate(-45deg);
  -o-transform: translateY(30px) rotate(-45deg);
  -ms-transform: translateY(30px) rotate(-45deg);
  transform: translateY(30px) rotate(-45deg);
}
80% {
  -webkit-transform: translateY(-10px) rotate(-45deg);
  -moz-transform: translateY(-10px) rotate(-45deg);
  -o-transform: translateY(-10px) rotate(-45deg);
  -ms-transform: translateY(-10px) rotate(-45deg);
  transform: translateY(-10px) rotate(-45deg);
}
100% {
  -webkit-transform: translateY(0) rotate(-45deg);
  -moz-transform: translateY(0) rotate(-45deg);
  -o-transform: translateY(0) rotate(-45deg);
  -ms-transform: translateY(0) rotate(-45deg);
  transform: translateY(0) rotate(-45deg);
}
}
@-webkit-keyframes bounce {
0% {
  opacity: 0;
  -ms-filter: "progid:DXImageTransform.Microsoft.Alpha(Opacity=0)";
  filter: alpha(opacity=0);
  -webkit-transform: translateY(-2000px) rotate(-45deg);
  -moz-transform: translateY(-2000px) rotate(-45deg);
  -o-transform: translateY(-2000px) rotate(-45deg);
  -ms-transform: translateY(-2000px) rotate(-45deg);
  transform: translateY(-2000px) rotate(-45deg);
}
60% {
  opacity: 1;
  -ms-filter: none;
  filter: none;
  -webkit-transform: translateY(30px) rotate(-45deg);
  -moz-transform: translateY(30px) rotate(-45deg);
  -o-transform: translateY(30px) rotate(-45deg);
  -ms-transform: translateY(30px) rotate(-45deg);
  transform: translateY(30px) rotate(-45deg);
}
80% {
  -webkit-transform: translateY(-10px) rotate(-45deg);
  -moz-transform: translateY(-10px) rotate(-45deg);
  -o-transform: translateY(-10px) rotate(-45deg);
  -ms-transform: translateY(-10px) rotate(-45deg);
  transform: translateY(-10px) rotate(-45deg);
}
100% {
  -webkit-transform: translateY(0) rotate(-45deg);
  -moz-transform: translateY(0) rotate(-45deg);
  -o-transform: translateY(0) rotate(-45deg);
  -ms-transform: translateY(0) rotate(-45deg);
  transform: translateY(0) rotate(-45deg);
}
}
@-o-keyframes bounce {
0% {
  opacity: 0;
  -ms-filter: "progid:DXImageTransform.Microsoft.Alpha(Opacity=0)";
  filter: alpha(opacity=0);
  -webkit-transform: translateY(-2000px) rotate(-45deg);
  -moz-transform: translateY(-2000px) rotate(-45deg);
  -o-transform: translateY(-2000px) rotate(-45deg);
  -ms-transform: translateY(-2000px) rotate(-45deg);
  transform: translateY(-2000px) rotate(-45deg);
}
60% {
  opacity: 1;
  -ms-filter: none;
  filter: none;
  -webkit-transform: translateY(30px) rotate(-45deg);
  -moz-transform: translateY(30px) rotate(-45deg);
  -o-transform: translateY(30px) rotate(-45deg);
  -ms-transform: translateY(30px) rotate(-45deg);
  transform: translateY(30px) rotate(-45deg);
}
80% {
  -webkit-transform: translateY(-10px) rotate(-45deg);
  -moz-transform: translateY(-10px) rotate(-45deg);
  -o-transform: translateY(-10px) rotate(-45deg);
  -ms-transform: translateY(-10px) rotate(-45deg);
  transform: translateY(-10px) rotate(-45deg);
}
100% {
  -webkit-transform: translateY(0) rotate(-45deg);
  -moz-transform: translateY(0) rotate(-45deg);
  -o-transform: translateY(0) rotate(-45deg);
  -ms-transform: translateY(0) rotate(-45deg);
  transform: translateY(0) rotate(-45deg);
}
}
@keyframes bounce {
0% {
  opacity: 0;
  -ms-filter: "progid:DXImageTransform.Microsoft.Alpha(Opacity=0)";
  filter: alpha(opacity=0);
  -webkit-transform: translateY(-2000px) rotate(-45deg);
  -moz-transform: translateY(-2000px) rotate(-45deg);
  -o-transform: translateY(-2000px) rotate(-45deg);
  -ms-transform: translateY(-2000px) rotate(-45deg);
  transform: translateY(-2000px) rotate(-45deg);
}
60% {
  opacity: 1;
  -ms-filter: none;
  filter: none;
  -webkit-transform: translateY(30px) rotate(-45deg);
  -moz-transform: translateY(30px) rotate(-45deg);
  -o-transform: translateY(30px) rotate(-45deg);
  -ms-transform: translateY(30px) rotate(-45deg);
  transform: translateY(30px) rotate(-45deg);
}
80% {
  -webkit-transform: translateY(-10px) rotate(-45deg);
  -moz-transform: translateY(-10px) rotate(-45deg);
  -o-transform: translateY(-10px) rotate(-45deg);
  -ms-transform: translateY(-10px) rotate(-45deg);
  transform: translateY(-10px) rotate(-45deg);
}
100% {
  -webkit-transform: translateY(0) rotate(-45deg);
  -moz-transform: translateY(0) rotate(-45deg);
  -o-transform: translateY(0) rotate(-45deg);
  -ms-transform: translateY(0) rotate(-45deg);
  transform: translateY(0) rotate(-45deg);
}
}
@media screen and (max-width: 574px) {
 



  #input-container {
    display:none
  }





}

.loader {
  -webkit-animation: load-out 10s;
  animation: load-out 6s;
  -webkit-animation-fill-mode: forwards;
  animation-fill-mode: forwards;
}

@-webkit-keyframes load-out {

 from {
      top: 0;
      opacity: 1;
  }

  to {
      top: 100%;
      opacity: 0;
  }
}

@keyframes load-out {
  from {
      top: 0;
      opacity: 1;
  }

  to {
      top: 100%;
      opacity: 0;
  }
}


.mapboxgl-ctrl-geocoder {
font-size: 18px;
line-height: 24px;
font-family: "Open Sans", "Helvetica Neue", Arial, Helvetica, sans-serif;
position: relative;
background-color: #fff;
width: 100%;
min-width: 200px;
z-index: 1;
border-radius: 4px;
transition: width .25s, min-width .25s;

}

.mapboxgl-ctrl-geocoder--input {
font: inherit;
width: 100%;
border: 0;
background-color: transparent;
margin: 0;
height: 50px;
color: #404040; /* fallback */
color: rgba(0, 0, 0, 0.75);
padding: 6px 45px;
text-overflow: ellipsis;
white-space: nowrap;
overflow: hidden;
}

#menu {
      position: absolute;
      background: transparent;
      padding: 10px;
      font-family: 'Open Sans', sans-serif;
      
      display:flex;
      bottom:0;
      right:0;
      
  }
  .voice-button {
          display: inline-block;
          vertical-align: middle;
          margin-left: 10px;
          width: 32px;
          height: 32px;
          background-color: transparent ;
          border: none;
          border-radius: 50%;
          cursor: pointer;
            padding: 10px;
            
             position: absolute;
             margin-left:-33px;
             top:1px;

          padding: 10px;
          text-align: center;
      }
      .voice-button-icon:hover {
           fill: cyan ;
      }
      .voice-button-icon {
          width: 20px;
          height: 20px;
          margin: -1.5px;
          fill:#AAF3F3 ;
      }
      
      
      .calculation-box {
            height: 60px;
            width: 240px;
            position: absolute;
            bottom: 15px;
            left: 10px;
            background-color: #ffffff; /* White background */
            border-radius: 10px; /* Slightly more rounded corners */
            cursor: pointer;
            padding: 15px;
            text-align: center;
            z-index: 1;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1); /* Subtle shadow */
            transition: transform 0.3s, box-shadow 0.3s; /* Smooth transitions */
            font-family: Arial, sans-serif; /* Change the font for better readability */
            font-size: 16px; /* Increase font size */
            color: #333; /* Darker text color for better contrast */
        }

        .calculation-box:hover {
            box-shadow: 0 8px 16px rgba(0, 0, 0, 0.2); /* More pronounced shadow on hover */
            transform: translateY(-25px); /* Slightly lift the box on hover */
        }

        .calculation-box:active {
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1) inset; /* Inset shadow on click */
            transform: translateY(2px); /* Slightly move the box down on click */
        }
  p {
      font-family: 'sans-serif';
      margin: 0;
      font-size: 12px;
     
  }
  #tilequery {
      display:block;
      
  }
  
  /* margin: 150px; */
/* Style for the Mapbox Geocoder control */
.mapboxgl-ctrl-geocoder.mapboxgl-ctrl {
  background: transparent;
  border: none;
  color: transparent; /*https://api.mapbox.com/mapbox-gl-js/plugins/mapbox-gl-geocoder/v4.7.0/mapbox-gl-geocoder.css */
  
}
.mapboxgl-ctrl-geocoder.mapboxgl-ctrl input::placeholder {
  margin:3;
  color: white;
  
}


.mapboxgl-ctrl-geocoder--button  {
                        background: transparent;
                        
}


.coords {
background: rgba(0, 0, 0, 0.5);
color: #fff;
position: absolute;
bottom: 40px;
left: 10px;
padding: 5px 10px;
margin: 0;
font-size: 11px;
line-height: 18px;
border-radius: 3px;
display: none;
}
.popup {
  position: fixed;
  top: 20px; /* Adjust this value to control the distance from the top */
  right: 20px; /* Adjust this value to control the distance from the right */
  background-color: #f8f9fa;
  border: 1px solid #ced4da;
  padding: 15px;
  border-radius: 5px;
  box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
  display: none;
  z-index: 1;
}

.popup p {
  margin: 0;
}

.popup-close {
  position: absolute;
  top: 5px;
  right: 5px;
  cursor: pointer;
}
p {
  font-family: Arial, sans-serif;
  font-size: 13px;
}

h2{
  font-family: Arial, sans-serif;
  font-size: 23px;
  color:#186d7a;
}

@media screen and (max-width: 700px) {
 

.calculation-box {
      height: 30px;
      width: 100px;
      position: absolute;
      bottom: 10px;
      left: 10px;
      background-color: rgba(255, 255, 255, 0.9);
      border-radius: 6%;
          cursor: pointer;
            padding: 15px;
      text-align: center;
      z-index:  1;
  }

  p {
      font-family: 'sans-serif';
      margin: 0;
      font-size: 10px;
     
  }
  html, body{overflow:hidden;}
}


@media screen and (max-width: 700px) {
 

 .calculation-box {
       height: 30px;
       width: 100px;
       position: absolute;
       bottom: 10px;
       left: 10px;
       background-color: rgba(255, 255, 255, 0.9);
       border-radius: 6%;
           cursor: pointer;
             padding: 15px;
       text-align: center;
       z-index:  1;
   }
 
   p {
       font-family: 'sans-serif';
       margin: 0;
       font-size: 10px;
      
   }
   #menu {
       position: absolute;
       background: transparent;
       padding: 3px;
       font-family: 'Open Sans', sans-serif;
       font-size: 10px;
       display:flex;
       bottom:0;
       right:0;

      
   }  
   html, body{overflow:hidden;}
 }
 @media screen and (min-width: 700px) {
 }
</style>


</head>
<body>
<div class="loader">
<div class='pin'></div>
<div class='pulse'></div>
</div>

<script src="https://kit.fontawesome.com/30eb1ffcab.js" crossorigin="anonymous"></script>
<link rel="stylesheet" href="path/to/font-awesome/css/font-awesome.min.css">

<script src="https://unpkg.com/@turf/turf@6/turf.min.js"></script>
<script src="https://api.mapbox.com/mapbox-gl-js/plugins/mapbox-gl-draw/v1.4.0/mapbox-gl-draw.js"></script>
<link rel="stylesheet" href="https://api.mapbox.com/mapbox-gl-js/plugins/mapbox-gl-draw/v1.4.0/mapbox-gl-draw.css" type="text/css">
<div id="map"></div>

<div class="calculation-box" id="toggleButton" >
  <p>Draw a polygon for area and density</p>
  <div id="calculated-area"></div>
     <div id="weather-info" class="weather-info"></div>
     <button class="sup" id="toggleButton">MapChat</button>

</div>
<style>
        .sup {
           
            border: none; /* Remove borders */
          
            padding: 5px 5px; /* Add some padding */
            text-align: center; /* Center the text */
            text-decoration: none; /* Remove underline */
            display: inline-block; /* Make the link block level */
            font-size: 16px; /* Increase font size */
            margin: 4px 2px; /* Add some margin */
            cursor: pointer; /* Add a pointer on hover */
            border-radius: 12px; /* Rounded corners */
            transition: background-color 0.3s, box-shadow 0.3s; /* Add transition for hover effects */
        }

        .sup:hover {
          
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3); /* Add shadow on hover */
        }

        .sup:active {
           
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3) inset; /* Inset shadow when clicked */
            transform: translateY(2px); /* Slightly move the button down */
        }
    </style>
<script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
  <script src="https://code.jquery.com/ui/1.12.1/jquery-ui.min.js"></script>
  <style>
    #iframe-container {
      display: none;
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: 30%;
      height: 30%;
      z-index: 9999;
      border: 2px solid #333;
      border-radius: 5px;
      overflow: hidden;
    }

    #myIframe {
      width: 100%;
      height: 100%;
      border: none;
    }

    #sup {
  position: fixed;
  top: 20px;
  right: 20px;
  padding: 12px 24px; /* Slightly increased padding for a bigger appearance */
  background-color: #fff; /* White background */
  color: #333; /* Button text color */
  border: 2px solid #333; /* Button border */
  border-radius: 5px; /* Rounded corners */
  cursor: pointer;
  font-size: 18px; /* Increased font size */
  font-weight: bold;
  transition: background-color 0.3s ease, color 0.3s ease, border-color 0.3s ease; /* Transition effect */
  z-index: 10000; /* Ensure the button is above other content */
}

#sup:hover {
  background-color: #f0f0f0; /* Button background color on hover */
  color: #555; /* Button text color on hover */
}

#sup:focus {
  outline: none; /* Remove focus outline */
}


  </style>
  <script src="https://cdn.jsdelivr.net/npm/driver.js/dist/driver.min.js"></script>

</head>
<body>
  
  <div id="input-container">
    <input type="number" id="populationInput" placeholder="Enter the number of people">
    <button onclick="addMarkerWithInput()" style=" height: 30px;">Add Number</button>
  </div>
  <button class="fa-solid fa-map-location-dot" id="toggle-btn" style="position: absolute; font-size: 17px; height:33px;  padding: 5px ; color:#393939; display:flex;  transform: translateY(80%); right: 80px; position: absolute; top: 20px; right: 50px; z-index: 1; border-radius: 20%;"></button>

<!-- Localhost seperate file for texting s-->
  <div id="iframe-container">
    <iframe id="myIframe" src="https://projectxtended.onrender.com" frameborder="0"></iframe>
  </div>


  <script>
    $(document).ready(function() {
      $("#toggleButton").click(function() {
        $("#iframe-container").toggle();
      });

      $("#iframe-container").draggable();
      $("#iframe-container").resizable();
    });

    
  </script>

  <link href="https://cdnjs.cloudflare.com/ajax/libs/intro.js/4.0.0/introjs.min.css" rel="stylesheet">
  <!-- Custom CSS for highlighting elements -->
  <style>
    .introjs-fixParent {
      z-index: 9999999 !important;
    }
    .introjs-tooltip {
      max-width: 400px;
    }
    .custom-introjs-skipbutton {
      background-color: #f44336;
      color: white;
      border: none;
      padding: 5px 10px;
      border-radius: 4px;
    }
    .custom-introjs-nextbutton {
      background-color: #4CAF50;
      color: white;
      border: none;
      padding: 5px 10px;
      border-radius: 4px;
    }

    @keyframes highlight {
  0% { border: 2px solid yellow; }
  50% { border: 4px solid orange; }
  100% { border: 2px solid yellow; }
}

.mapbox-gl-draw_ctrl-draw-btn.mapbox-gl-draw_polygon.highlighted {
  animation: highlight 1.5s infinite;
}

  </style>
<div class="popup" id="popup">
  <span class="popup-close" id="popup-close">&times;</span>
  <h2>How to use Pinpoint!</h2>
 <center> <button style=" height: 30px;" id="startTour">Start Tutorial</button></center>
    </div>
   
    </div>
</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/intro.js/4.0.0/intro.min.js"></script>
  <script>
    document.getElementById('startTour').addEventListener('click', function() {
      var intro = introJs();
      intro.setOptions({
        steps: [
          {
            intro: "Ever wished you could check Walmart and Kroger's crowd levels in real-time, ensuring a faster shopping trip? Well Welcome to PinPoint! This is a map website that helps people know where to go based on location data and user information.",
          },
          {
            element: document.querySelector('.calculation-box'),
            intro: "See the area and density polygon, explore real-time weather updates. MapChat: pinpoint locations and manually input population counts!",
            position: 'right'
          },
          {
            element: document.querySelector('#input-container'),
            intro: "Input the number of people on the map and add a marker to the map for personal use.",
            position: 'left'
          },
          {
            element: document.querySelector('#toggle-btn'),
            intro: "This is the map button where you can toggle different map styles. *Use line tool if you clicked this for directions*.",
            position: 'top'
          },
          {
            element: document.querySelector('#mapbox-directions'),
            intro: "Top left is where you can get directions to where to go.",
            position: 'top'
          },
          {
            element: document.querySelector('#leftleft'),
            intro: "On the right draw polygons on the map using the polygon tool (it is highlight), zoom in and out of the map, rotate map and pinpoint your location. ",
            position: 'top'
          },
          {
            element: document.querySelector('.tyuhijo'),
            intro: "Click X on ''How to use pinpoint'' to get out of tutorial mode and have fun with Pinpoint!",
            position: 'top'
          },
        ],
        tooltipClass: 'custom-introjs-tooltip',
        highlightClass: 'custom-introjs-highlight',
        exitOnEsc: true,
        exitOnOverlayClick: false,
        showStepNumbers: false,
        showProgress: true,
        showBullets: false,
        doneLabel: 'Done',
        nextLabel: 'Next',
        prevLabel: 'Back',
        skipLabel: 'Skip',
        scrollToElement: true,
        scrollTo: 'tooltip',
        overlayOpacity: 0.5,
        positionPrecedence: ["bottom", "top", "right", "left"],
        stepsOrder: 'forward',
        hintAnimation: true
      });
        
      document.querySelector(".mapbox-gl-draw_ctrl-draw-btn.mapbox-gl-draw_polygon").setAttribute("title", "PopulationCount");

      document.querySelector(".mapbox-gl-draw_ctrl-draw-btn.mapbox-gl-draw_polygon").classList.add("highlighted");

// Add an event listener to the draw polygon button to remove the highlighted class
document.querySelector(".mapbox-gl-draw_ctrl-draw-btn.mapbox-gl-draw_polygon").addEventListener('click', function() {
    document.querySelector(".mapbox-gl-draw_ctrl-draw-btn.mapbox-gl-draw_polygon").classList.remove("highlighted");
}, { once: true }); 

      intro.start();
      
    });
  </script>
<script>
var closebtns = document.getElementsByClassName("close");
var i;

for (i = 0; i < closebtns.length; i++) {
closebtns[i].addEventListener("click", function() {
  this.parentElement.style.display = 'none';
});
}

document.addEventListener("DOMContentLoaded", function() {
  var popup = document.getElementById('popup');
  var closeButton = document.getElementById('popup-close');
  
  // Check if the popup has been closed before
  if (!localStorage.getItem('popupClosed')) {
    popup.style.display = 'block';
  }
  
  // Close the popup when the close button is clicked
  closeButton.addEventListener('click', function() {
    popup.style.display = 'none';
    // Set flag in local storage to indicate popup has been closed
    localStorage.setItem('popupClosed', 'true');
  });
});

</script>

<style>
  /* Popup Styles */
  .random-container {
    position: fixed;
    top: 20px;
    right: 20px;
    background-color: #fff;
    border: 1px solid #ccc;
    padding: 10px;
    border-radius: 5px;
    box-shadow: 0 2px 5px rgba(0,0,0,0.2);
    display: none;
  }
  
  /* Animation for popup */
  .random-container.show-popup {
    display: block;
    animation: slideInRight 0.5s ease forwards;
  }

  @keyframes slideInRight {
    0% {
      transform: translateX(100%);
    }
    100% {
      transform: translateX(0);
    }
  }

  /* Animation for bottom line */
  .bottom-line {
    position: fixed;
    bottom: 0;
    width: 100%;
    height: 2px;
    background-color: #007bff;
    animation: bottomLineAnimation 5s forwards;
    display: none;
  }

  @keyframes bottomLineAnimation {
    0% {
      width: 100%;
    }
    100% {
      width: 0%;
    }
  }
</style>
</head>
<body>
<div class="random-container" id="popup2" style="z-index: 100; height: 30px;">
  <p>Congrats on the streak! Keep it up!</p>
  <p>Your streak: <span id="streak">0</span></p>
</div>
<div class="bottom-line" id="bottom-line"></div>
<center> <div id="error-message-container" style="position: fixed;"></div></center>
<script>
  // Function to show popup
  function showPopup() {
    document.getElementById('popup2').classList.add('show-popup');
    setTimeout(hidePopup, 5000); // Hide after 5 seconds
  }

  // Function to hide popup
  function hidePopup() {
    document.getElementById('popup2').classList.remove('show-popup');
  }

  // Function to update streak
  function updateStreak() {
    let streak = localStorage.getItem('streak') || 0;
    streak++;
    localStorage.setItem('streak', streak);
    document.getElementById('streak').textContent = streak;
  }

  // Check if streak exists in localStorage
  if (localStorage.getItem('streak')) {
    // If streak exists, update streak
    updateStreak();
    // Show popup
    showPopup();
  } else {
    // If streak doesn't exist, set streak to 1
    localStorage.setItem('streak', 1);
  }

  // Show bottom line animation
  document.getElementById('bottom-line').style.display = 'block';

</script>

<style>
  .btnName{
    accent-color: #08e2e2;

 
   
  /* The border will be the spacing between the dot and the outer circle */
  border: 3px solid #FFF;

 
  }
  @media screen and (max-width: 519px) {
    .calculation-box{
                bottom: 30px;
                top: 80%; /* Move the menu higher on the screen */
                height: 48px;
            }

            .sup {
           
           border: none; /* Remove borders */
         
           padding: 5px 5px; /* Add some padding */
           text-align: center; /* Center the text */
           text-decoration: none; /* Remove underline */
           display: inline-block; /* Make the link block level */
           font-size: 10px; /* Increase font size */
           margin: 4px 2px; /* Add some margin */
           cursor: pointer; /* Add a pointer on hover */
           border-radius: 12px; /* Rounded corners */
           transition: background-color 0.3s, box-shadow 0.3s; /* Add transition for hover effects */
       }

       #iframe-container {
      display: none;
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: 65%;
      height: 45%;
      z-index: 9999;
      border: 2px solid #333;
      border-radius: 5px;
      overflow: hidden;
    }

        }
    .mapboxgl-ctrl-attrib {
        font-size: 10px; /* Smaller text */
        color: rgba(255, 255, 255, 0.7); /* Lighter color */
        background: rgba(0, 0, 0, 0.5); /* Semi-transparent background */
        padding: 2px 5px; /* Smaller padding */
        border-radius: 3px; /* Rounded corners */
    }

    /* Use an icon for attribution */
    .mapboxgl-ctrl-attrib::before {
        content: url('https://example.com/icon.png'); /* URL to your icon */
        display: inline-block;
        margin-right: 5px;
        vertical-align: middle;
    }

    .mapboxgl-ctrl-attrib a {
        display: none; /* Hide the text links */
    }
    
    #menu {
    display: none;
    opacity: 0;
    transition: opacity 0.5s ease-in-out;
 
}

#menu.show {
    display: inline-flex;
    opacity: 1;
}

.btnName {
    margin-bottom: 10px;
}


@media screen and (max-width: 700px) {
 
  #toggle-btn{
  top: 120px;
}
}
</style>
<div id="menu">
<!-- Add an input field for users to input population count -->

  <!-- https://docs.mapbox.com/api/maps/styles/#mapbox-styles -->
  <input id="navigation-night-v1" type="radio" name="rtoggle" value="light" checked="checked" class="btnName">
  <label for="navigation-night-v1" style="color:rgb(0, 0, 0)" >Default</label>
  <input id="satellite-streets-v12" type="radio" name="rtoggle" value="satellite" class="btnName">
  <label for="satellite-streets-v12" style="color:rgb(0, 0, 0)">Satellite</label>
  <input id="streets-v11" type="radio" name="rtoggle" value="dark" class="btnName">
  <label for="streets-v11" style="color:rgb(0, 0, 0)">Lights</label>
  <input id="streets-v8" type="radio" name="rtoggle" value="streets" class="btnName">
  <label for="streets-v8" style="color:rgb(0, 0, 0)">Streets</label>
  <input id="outdoors-v12" type="radio" name="rtoggle" value="outdoors" class="btnName">
  <label for="outdoors-v12" style="color:rgb(0, 0, 0)">Outdoors</label>
  
  
  

</div>
</div>
<pre id="coords" class="coords"></pre>


<style>
  #features { display: none; }
  #features {
      position: absolute;
      top: 0;
      right: 0;
      bottom: 0;
      width: 50%;
      height:50%;
      overflow: auto;
      background:transparent
  }

  label {
            display: block;
            background-color: #ffffff; /* Blue background for labels */
            color: rgb(0, 0, 0);
            padding: 10px;
            border-radius: 5px;
            cursor: pointer;
            transition: background-color 0.3s, box-shadow 0.3s;
            
            text-align: center;
            width: 100%;
        }

        label:hover {
            background-color: white; /* Darker blue on hover */
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3); /* Shadow on hover */
        }

        label:active {
            background-color: #e1e6ea; /* Even darker blue on click */
            box-shadow: inset 0 4px 8px rgba(0, 0, 0, 0.3); /* Inset shadow on click */
        }


        .error-message {
    position: fixed; /* Ensure the message stays fixed at the top */
    top: 0px;
    left: 0; /* Ensure it spans from the left edge */
    width: 100%; /* Ensure it spans the full width of the screen */
    background: rgba(255, 0, 0, 0.8);
    color: white;
    text-align: center; /* Center the text */
    z-index: 999;
    padding: 5px 0; /* Optional: add padding for better readability */
}
</style>
<script>
  document.addEventListener('DOMContentLoaded', () => {
    const menu = document.getElementById('menu');
    const toggleBtn = document.getElementById('toggle-btn');

    toggleBtn.addEventListener('click', () => {
        if (menu.classList.contains('show')) {
            menu.classList.remove('show');
        } else {
            menu.classList.add('show');
        }
    });
});

  let isMicEnabled = false;
  let recognition;

  function startRecognition() {
    if (('SpeechRecognition' in window || 'webkitSpeechRecognition' in window) && !isMicEnabled) {
      recognition = new (window.SpeechRecognition || window.webkitSpeechRecognition)();
      recognition.continuous = true;
      recognition.interimResults = true;

      recognition.onstart = () => {
        console.log('Speech recognition started...');
      };

      recognition.onresult = (event) => {
        const transcript = event.results[event.results.length - 1][0].transcript;
        const activeElement = document.activeElement;

        if (activeElement && (activeElement.tagName === 'INPUT' || activeElement.tagName === 'TEXTAREA')) {
          activeElement.value += transcript;
        }
      };

      recognition.start();
      isMicEnabled = true;
    }
  }

  function stopRecognition() {
    if (recognition && isMicEnabled) {
      recognition.stop();
      isMicEnabled = false;
    }
  }

  document.getElementById('toggleButton').addEventListener('click', () => {
    if (isMicEnabled) {
      stopRecognition();
    } else {
      startRecognition();
    }
  });
  
  
</script>

<!-- Container for the error message -->



<script>
 mapboxgl.accessToken = 'pk.eyJ1IjoiMHB1aW1sb3JkNDQ1IiwiYSI6ImNsdW4zNXUxbzFoaG8yaWxobnFtZTZlazgifQ.Lwq4vHwo2IoWXQEOO-P31Q';

  navigator.geolocation.getCurrentPosition(successLocation, errorLocation, {
    enableHighAccuracy: true
  });

  function successLocation(position) {
    setupMap([position.coords.longitude, position.coords.latitude]);
  }

  function errorLocation() {
    var errorMessage = document.createElement('div');
  errorMessage.className = 'error-message';
  errorMessage.textContent = 'Location access is blocked. Please enable location services to use this feature or it will not work properly :(';

  // Get the container to append the error message
  var errorMessageContainer = document.getElementById('error-message-container');

  // Append the error message to the container
  errorMessageContainer.appendChild(errorMessage);
  // Get the user's time zone
  const userTimeZone = Intl.DateTimeFormat().resolvedOptions().timeZone;

  // Define default locations associated with different time zones
  const timeZones = {
    'America/New_York': [-74.006, 40.7128],      // Example: New York City
    'Europe/London': [-0.1276, 51.5074],         // Example: London
    'Europe/Paris': [2.3522, 48.8566],           // Example: Paris
    'America/Los_Angeles': [-118.2437, 34.0522]  // Example: Los Angeles
    // Add more time zones and their associated default locations as needed
  };

  // Set the default location based on the user's time zone
  const defaultLocation = timeZones[userTimeZone] || [0, 0]; // Default to [0, 0] if time zone not found

  setupMap(defaultLocation);
}

  const ws = new WebSocket('ws://localhost:8080');

ws.onopen = () => {
  console.log('Connected to WebSocket server');
};

ws.onmessage = (event) => {
  const message = event.data;

  console.log('Received message from client:', message);

  // Parse the message as JSON
  try {
    const messageData = JSON.parse(message);

    // Check if the message data is valid
    if (
      messageData &&
      (messageData.type === 'location' || messageData.type === 'locationUpdate') &&
      Array.isArray(messageData.location) &&
      messageData.location.length === 2
    ) {
      const [longitude, latitude] = messageData.location;

      // Call the function to add marker with the extracted location
      addMarker([longitude, latitude]);
    } 
  } catch (error) {
    console.error('Error parsing message:', error);
  }
 // addMarkerWithCount(center, populationCount);


 if (
      messageData &&
      messageData.type === 'addMarker' &&
      Array.isArray(messageData.coordinates) &&
      messageData.coordinates.length === 2
    ) {
      const [longitude, latitude] = messageData.coordinates;

      // Call the function to add marker with the extracted location
      addMarkerWithCount((location, count), messageData.populationCount);
    } 
  
 
};
function addMarker(location) {
  console.log('Adding marker at location:', location);

  // Assuming map and mapboxgl are properly defined elsewhere in your code
  if (map && map.loaded()) {
    new mapboxgl.Marker({ color: getRandomColor() })
      .setLngLat(location)
      .addTo(map);
      
  } else {
    console.error('Map not available or not loaded');
  }
}

function getRandomColor() {
  const letters = '0123456789ABCDEF';
  let color = '#';
  for (let i = 0; i < 6; i++) {
    color += letters[Math.floor(Math.random() * 16)];
  }
  return color;
}


function addMarkerWithInput() {
  // Get the population count input value
  const populationInput = document.getElementById('populationInput');
  const populationCount = parseInt(populationInput.value);

  // Validate input
  if (isNaN(populationCount) || populationCount <= 0) {
    alert('Please enter a valid population count greater than 0.');
    return;
  }

  // Get the current map center
  const center = map.getCenter();

  // Add marker with the specified population count
  addMarkerWithCount(center, populationCount);
}

// Function to add marker with specified population count
function addMarkerWithCount(location, count) {
  console.log('Adding marker at location:', location);

  // Customize the marker appearance based on population count
  const color = getColorForPopulationCount(count);
  const marker = new mapboxgl.Marker({  draggable: true }) // Make marker draggable
    .setLngLat(location)
    .addTo(map);

  // Add number to the marker
  const markerElement = marker.getElement();
  markerElement.innerHTML = count;

  // Event listener to update marker position when dragged
  marker.on('dragend', () => {
    const newLngLat = marker.getLngLat();
    console.log('Marker dragged to:', newLngLat);
  });

  // Schedule marker deletion after 10 minutes
  
}


// Function to assign colors based on population count
function getColorForPopulationCount(count) {
  // Define your color logic based on population count ranges
  // For example, you can use different colors for different ranges


}


map.on('mousemove', (e) => {
        const features = map.queryRenderedFeatures(e.point);

        const displayProperties = [
            'type',
            'properties',
            'id',
            'layer',
            'source',
            'sourceLayer',
            'state'
        ];

        const displayFeatures = features.map((feat) => {
            const displayFeat = {};
            displayProperties.forEach((prop) => {
                displayFeat[prop] = feat[prop];
            });
            return displayFeat;
        });

        document.getElementById('features').innerHTML = JSON.stringify(
            displayFeatures,
            null,
            2
        );
    });

    document.addEventListener('keydown', (event) => {
        if (event.key === 'i' || event.key === 'I') {
            const featuresPopup = document.getElementById('features');
            featuresPopup.style.display = (featuresPopup.style.display === 'block') ? 'none' : 'block';
        }
    });
  
  
    function setupMap(center) {
  
   map = new mapboxgl.Map({
    container: 'map',
    style: 'mapbox://styles/mapbox/navigation-night-v1',
    center: center,
    zoom: 15
    });

  
  map.on('load', () => {
     
      addMarker(center);
      ws.send(JSON.stringify({ type: 'location', location: center }));
    });


  
const layerList = document.getElementById('menu');
  const inputs = layerList.getElementsByTagName('input');
//here it is making new layers where I cant see things input layer
  for (const input of inputs) {
      input.onclick = (layer) => {
          const layerId = layer.target.id;
          map.setStyle('mapbox://styles/mapbox/' + layerId);
      };
  }//here
  
  for (const input of inputs) {
input.onclick = (layer) => {
  const layerId = layer.target.id;
  map.setStyle('mapbox://styles/mapbox/' + layerId);

  // Store the selected map style in local storage
  localStorage.setItem('selectedMapStyle', layerId);
};
}

// Add this code to set the initial map style based on stored preference
const storedMapStyle = localStorage.getItem('selectedMapStyle');
if (storedMapStyle) {
map.setStyle('mapbox://styles/mapbox/' + storedMapStyle);
}


  fetchWeatherData(center);
  
const draw = new MapboxDraw({
displayControlsDefault: true,
controls: {
  polygon: true,
  trash: true,
  point: false,
  line_string: true,
},
styles: [
  // Set the line style for the user-input coordinates
  {
    'id': 'gl-draw-line',
    'type': 'line',
    'filter': [
      'all',
      ['!=', 'mode', 'static'],
      ['==', '$type', 'LineString'],
    ],
    'layout': {
      'line-cap': 'round',
      'line-join': 'round'
    },
    'paint': {
      'line-color': '#438EE4',
      'line-dasharray': [0.2, 2],
      'line-width': 2,
      'line-opacity': 0.7
    }
  },
  // Style the vertex point halos
  {
    'id': 'gl-draw-polygon-and-line-vertex-halo-active',
    'type': 'circle',
    'filter': [
      'all',
      ['==', 'meta', 'vertex'],
      ['==', '$type', 'Point'],
      ['!=', 'mode', 'static']
    ],
    'paint': {
      'circle-radius': 12,
      'circle-color': '#FFF'
    }
  },
  // Style the vertex points
  {
    'id': 'gl-draw-polygon-and-line-vertex-active',
    'type': 'circle',
    'filter': [
      'all',
      ['==', 'meta', 'vertex'],
      ['==', '$type', 'Point'],
      ['!=', 'mode', 'static']
    ],
    'paint': {
      'circle-radius': 8,
      'circle-color': '#438EE4'
    }
  },
  // Style the polygon fill
  {
    'id': 'gl-draw-polygon-fill',
    'type': 'fill',
    'filter': ['all', ['==', '$type', 'Polygon'], ['!=', 'mode', 'static']],
    'paint': {
      'fill-color': '#438EE4', // You can change this color to blue
      'fill-opacity': 0.1, // Adjust the opacity as needed
    }
  }
]
});

map.addControl(draw);

let pointCount = 0;

map.on('draw.create', (event) => {
pointCount++;
if (pointCount >= 2) {
  disableDraw();
}
});

map.on('draw.delete', () => {
pointCount--;
enableDraw();
});

function enableDraw() {
map.on('click', addPointOnClick);
}

function disableDraw() {
map.off('click', addPointOnClick);
}

function addPointOnClick(e) {
if (pointCount < 2) {
  draw.add({
    type: 'Feature',
    properties: {},
    geometry: {
      type: 'Point',
      coordinates: [e.lngLat.lng, e.lngLat.lat]
    }
  });
}
}

map.on('draw.create', updateArea);
map.on('draw.delete', updateArea);
map.on('draw.update', updateArea);

function updateRoute() {
        removeRoute(); // Overwrite any existing layers

        const profile = 'driving'; // Set the profile

        // Get the coordinates
        const data = draw.getAll();
        const lastFeature = data.features.length - 1;
        const coords = data.features[lastFeature].geometry.coordinates;
        // Format the coordinates
        const newCoords = coords.join(';');
        // Set the radius for each coordinate pair to 25 meters
        const radius = coords.map(() => 25);
        getMatch(newCoords, radius, profile);
      }

      // Make a Map Matching request
      async function getMatch(coordinates, radius, profile) {
        // Separate the radiuses with semicolons
        const radiuses = radius.join(';');
        // Create the query
        const query = await fetch(
          `https://api.mapbox.com/matching/v5/mapbox/${profile}/${coordinates}?geometries=geojson&radiuses=${radiuses}&steps=true&access_token=${mapboxgl.accessToken}`,
          { method: 'GET' }
        );
        const response = await query.json();
        // Handle errors
        if (response.code !== 'Ok') {
          alert(
            `${response.code} - ${response.message}.\n\nFor more information: https://docs.mapbox.com/api/navigation/map-matching/#map-matching-api-errors`
          );
          return;
        }
        const coords = response.matchings[0].geometry;
        // Draw the route on the map
        addRoute(coords);
        getInstructions(response.matchings[0]);
      }

      function getInstructions(data) {
        // Target the sidebar to add the instructions
        const directions = document.getElementById('directions');
        let tripDirections = '';
        // Output the instructions for each step of each leg in the response object
        for (const leg of data.legs) {
          const steps = leg.steps;
          for (const step of steps) {
            tripDirections += `<li>${step.maneuver.instruction}</li>`;
          }
        }
        directions.innerHTML = `<p><strong>Trip duration: ${Math.floor(
          data.duration / 60
        )} min.</strong></p><ol>${tripDirections}</ol>`;
      }

      // Draw the Map Matching route as a new layer on the map
      function addRoute(coords) {
        // If a route is already loaded, remove it
        if (map.getSource('route')) {
          map.removeLayer('route');
          map.removeSource('route');
        } else {
          map.addLayer({
            'id': 'route',
            'type': 'line',
            'source': {
              'type': 'geojson',
              'data': {
                'type': 'Feature',
                'properties': {},
                'geometry': coords
              }
            },
            'layout': {
              'line-join': 'round',
              'line-cap': 'round'
            },
            'paint': {
              'line-color': '#03AA46',
              'line-width': 8,
              'line-opacity': 0.8
            }
          });
        }
      }

      // If the user clicks the delete draw button, remove the layer if it exists
      function removeRoute() {
        if (!map.getSource('route')) return;
        map.removeLayer('route');
        map.removeSource('route');
      }

 const peoplePerSquareUnitGuess = 90; // Adjust this value as needed


function updateArea(e) {
  const data = draw.getAll();
  const answer = document.getElementById('calculated-area');
  if (data.features.length > 0) {
      const area = turf.area(data);
      // Replace this with your actual population density data
      const populationDensity = 100; // people per square kilometer

      // Calculate the estimated population
      const estimatedPopulation = populationDensity * (area / 1000000); // Convert square meters to square kilometers

      answer.innerHTML = `<p><strong>${area.toFixed(2)}</strong></p><p>square meters</p>`;
      answer.innerHTML += `<p>Estimated Population: <strong>${Math.round(estimatedPopulation)}</strong></p>`;
  } else {
      answer.innerHTML = '';
      if (e.type !== 'draw.delete')
          alert('Click the map to draw a polygon.');
  }
}


const nav = new mapboxgl.NavigationControl();
    map.addControl(nav);

    var directions = new MapboxDirections({
      accessToken: mapboxgl.accessToken
      
    
    });


    map.addControl(directions, 'top-left');
    
    map.addControl(new mapboxgl.FullscreenControl({ container: document.querySelector('body')
    
                             
    }));
//io

map.addControl(
new mapboxgl.GeolocateControl({
positionOptions: {
enableHighAccuracy: true
},
// When active the map will receive updates to the device's location as it changes.
trackUserLocation: true,
// Draw an arrow next to the location dot to indicate which direction the device is heading.
showUserHeading: true
})
);
function addMarkerWithInput() {
  // Get the population count input value
  const populationInput = document.getElementById('populationInput');
  const populationCount = parseInt(populationInput.value);

  // Validate input
  if (isNaN(populationCount) || populationCount <= 0) {
    alert('Please enter a valid population count greater than 0.');
    return;
  }

  // Get the current map center
  const center = map.getCenter();

  // Add marker with the specified population count
  addMarkerWithCount(center, populationCount);

  // Optionally, you can send this data to the server via WebSocket for further processing or storage
  const markerData = {
    location: [center.lng, center.lat],
    count: populationCount
  };
  ws.send(JSON.stringify({ type: 'crowdData', people: [markerData] }));
}
function addMarkerWithCount(location, count) {
  console.log('Adding marker at location:', location);

  // Assuming map and mapboxgl are properly defined elsewhere in your code
  if (map && map.loaded()) {
    // Customize the marker appearance based on population count
    const color = getColorForPopulationCount(count);
    new mapboxgl.Marker({ color: color })
      .setLngLat(location)
      .addTo(map);
  } else {
    console.error('Map not available or not loaded');
  }
}

// Function to assign colors based on population count
function getColorForPopulationCount(count) {
  // Define your color logic based on population count ranges
  // For example, you can use different colors for different ranges
  if (count < 50) {
    return '#00FF00'; // Green
  } else if (count < 100) {
    return '#FFFF00'; // Yellow
  } else {
    return '#FF0000'; // Red
  }
}

//const marker = new mapboxgl.Marker({
//draggable: true
//})
//.setLngLat([0, 0])
//.addTo(map);

//localStorage.setItem();
//save marker 4 local storage and allow it to be togglable
//function onDragEnd() {
//const lngLat = marker.getLngLat();
//coords.style.display = 'block';
//coords.innerHTML = `Longitude: ${lngLat.lng}<br />Latitude: ${lngLat.lat}`;
//}

//marker.on('dragend', onDragEnd);

    map.on('load', () => {
      const geocoder = new MapboxGeocoder({
        accessToken: mapboxgl.accessToken,
        mapboxgl: mapboxgl,
        zoom: 13,
        placeholder: '           Enter to pinpoint...',
        //change size
      });

      map.addControl(geocoder, 'top-left');


      const marker = new mapboxgl.Marker({
        'color': '#00FFFF '
      });

      let userDuration = 0;

      geocoder.on('result', async (event) => {
        const point = event.result.center;
        const tileset = 'examples.dl46ljcs';
        const radius = 1609;
        const limit = 50;
        marker.setLngLat(point).addTo(map);
        const query = await fetch(
          `https://api.mapbox.com/v4/${tileset}/tilequery/${point[0]},${point[1]}.json?radius=${radius}&limit=${limit}&access_token=${mapboxgl.accessToken}`,
          { method: 'GET' }
        );
        const json = await query.json();
        map.getSource('tilequery').setData(json);

        const markerData = {
    lng: point[0],
    lat: point[1],
    duration: userDuration
  };
  ws.send(JSON.stringify(markerData)); // WebSocket communication

        
      });

      map.addSource('tilequery', {
        type: 'geojson',
        data: {
          'type': 'FeatureCollection',
          'features': [],
         
        }
        
      } );

 map.addLayer({
        id: 'tilequery-points',
       
        type: 'circle',
        source: 'tilequery',
       
      });
     
      const popup = new mapboxgl.Popup();

    map.on('mouseenter', 'tilequery-points', (event) => {
  map.getCanvas().style.cursor = 'pointer';
  const properties = event.features[0].properties;
  const obj = JSON.parse(properties.tilequery);
  const coordinates = new mapboxgl.LngLat(
    properties.longitude,
    properties.latitude,
  );

  console.log('Popup properties:', properties);
  console.log('Popup distance:', obj.distance);

        const content = `
    <h3>${properties.STORE_NAME}</h3>
    <h4>${properties.STORE_TYPE}</h4>
    <p>${properties.ADDRESS_LINE1}</p>
    <p>${(obj.distance / 1609.344).toFixed(2)} mi. from location</p>
    <input type="number" id="durationInput" placeholder="1 to 20 minutes">
  `;

  popup.setLngLat(coordinates).setHTML(content).addTo(map);

  // Listen for input change event and update duration
  const durationInput = document.getElementById('durationInput');
  durationInput.addEventListener('change', (e) => {
    userDuration = parseInt(e.target.value);
    // Update marker duration when changed
    ws.send(JSON.stringify({ duration: userDuration }));
  });
      });
    
      map.on('mouseleave', 'tilequery-points', () => {
        map.getCanvas().style.cursor = '';
        popup.remove();
      });
    });
  }
    


async function fetchWeatherData(coords) {
  const apiKey = 'f5a61986aa077076d9bd1c4dc12b2e1d';
  const apiUrl = `https://api.openweathermap.org/data/2.5/weather?lat=${coords[1]}&lon=${coords[0]}&appid=${apiKey}&units=metric`;

  try {
    const response = await fetch(apiUrl);
    const data = await response.json();

    // Display temperature information on the map
    const temperature = data.main.temp;
    const weatherInfo = document.getElementById('weather-info');
    weatherInfo.innerHTML = `<p>Temperature: ${temperature}°C</p>`;
  } catch (error) {
    console.error('Error fetching weather data:', error);
  }
}


//if you do not click X it will not show markers




</script>
<style>
   #input-container { position: absolute; top: 10px; right: 50px; z-index: 1; }
</style>
</body>

</html>




